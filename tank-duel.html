<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Tank Duel â€” Dual Mode</title>
<style>
:root{
  --bg:#191919; --panel:#222; --txt:#e8eef3;
  --p1:#00ffa6; --p2:#ff5675; --accent:#facc15;
}
html,body{margin:0;height:100%;background:var(--bg);color:var(--txt);
  font-family:Inter,system-ui,Segoe UI,Roboto,Arial;display:flex;align-items:center;justify-content:center}
.wrap{width:min(96vw,560px);padding:16px}
h1{margin:0 0 8px;font-size:18px;text-align:center}
.ctrls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin:8px 0}
select,button,input[type=range]{background:#202020;border:1px solid #2b2b2b;color:#fff;border-radius:10px}
button{padding:8px 12px;cursor:pointer}
.primary{background:var(--p1);border:none;color:#0b1612;font-weight:800}
small{opacity:.85}
.canvasWrap{background:var(--panel);border-radius:14px;box-shadow:0 18px 45px rgba(0,0,0,.55);padding:8px}
canvas{display:block;width:100%;height:auto;border-radius:10px;background:#151515}
.info{margin-top:8px;text-align:center;font-size:13px;color:#cbd5e1}
.badges{display:flex;justify-content:space-between;margin:6px 0}
.badge{background:#1a1a1a;border:1px solid #2a2a2a;padding:6px 10px;border-radius:10px;font-weight:700}
.range{display:flex;align-items:center;gap:8px}
.range input{width:140px;height:6px}
.hpbar{height:10px;border-radius:6px;background:#2a2a2a;overflow:hidden}
.hpbar > div{height:100%}
</style>
</head>
<body>
<div class="wrap">
  <h1>Tank Duel â€” Dual Mode</h1>

  <div class="badges">
    <div class="badge">P1 HP
      <div class="hpbar"><div id="hp1" style="width:100%;background:linear-gradient(90deg,#00ffa6,#40ffd0)"></div></div>
    </div>
    <div class="badge">P2/Bot HP
      <div class="hpbar"><div id="hp2" style="width:100%;background:linear-gradient(90deg,#ff5675,#ff8aa1)"></div></div>
    </div>
  </div>

  <div class="ctrls">
    <select id="mode">
      <option value="bot" selected>You vs Bot</option>
      <option value="2p">2 Players</option>
    </select>
    <div class="range">
      <label>Angle <small>(Â°)</small></label>
      <input id="angle" type="range" min="5" max="85" value="45">
      <span id="angleVal">45</span>
    </div>
    <div class="range">
      <label>Power</label>
      <input id="power" type="range" min="20" max="90" value="55">
      <span id="powerVal">55</span>
    </div>
    <button id="fire" class="primary">Fire</button>
    <button id="restart">Restart</button>
  </div>

  <div class="canvasWrap">
    <canvas id="game" width="520" height="320" aria-label="Tank Duel Canvas"></canvas>
  </div>

  <div class="info" id="status">Turn: <b style="color:var(--p1)">P1</b>. Adjust angle & power â†’ Fire.</div>
</div>

<script>
/* Tank Duel â€” compact artillery game. #191919 bg, bot/2P modes, angle+power, health, explosions */
const cvs=document.getElementById('game'), ctx=cvs.getContext('2d');
const W=cvs.width, H=cvs.height, G=0.35; // gravity
const statusEl=document.getElementById('status');
const hp1El=document.getElementById('hp1'), hp2El=document.getElementById('hp2');

const ui={
  mode:document.getElementById('mode'),
  angle:document.getElementById('angle'),
  power:document.getElementById('power'),
  angleVal:document.getElementById('angleVal'),
  powerVal:document.getElementById('powerVal'),
  fire:document.getElementById('fire'),
  restart:document.getElementById('restart')
};

let mode='bot', turn=1, tanks, shell=null, wind=0, gameOver=false;

function reset(){
  gameOver=false; shell=null; turn=1; wind=(Math.random()*0.4-0.2); // small wind
  tanks=[
    {x:60, y:H-40, r:12, color:get('--p1'), hp:100, dir:1},
    {x:W-60, y:H-40, r:12, color:get('--p2'), hp:100, dir:-1}
  ];
  updateHP();
  ui.angle.value=45; ui.power.value=55; syncLabels();
  drawScene();
  statusEl.innerHTML='Turn: <b style="color:var(--p1)">P1</b>. Adjust angle & power â†’ Fire.';
  if(mode==='bot' && turn===2) setTimeout(botFire,700);
}
function get(name){return getComputedStyle(document.documentElement).getPropertyValue(name).trim();}
function syncLabels(){ ui.angleVal.textContent=ui.angle.value; ui.powerVal.textContent=ui.power.value; }
ui.angle.oninput=syncLabels; ui.power.oninput=syncLabels;
ui.mode.onchange=(e)=>{ mode=e.target.value; reset(); };
ui.fire.onclick=()=>{ if(!gameOver && (!shell)) fire(turn); };
ui.restart.onclick=reset;

function drawScene(){
  ctx.clearRect(0,0,W,H);
  // sky gradient
  const g=ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#141414'); g.addColorStop(1,'#181818');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  // ground
  ctx.fillStyle='#0f0f0f'; ctx.fillRect(0,H-28,W,28);
  // wind indicator
  ctx.fillStyle='#cbd5e1'; ctx.font='12px sans-serif';
  ctx.fillText(`Wind: ${wind>0?'+':''}${wind.toFixed(2)}`, W-110, 18);

  // tanks
  tanks.forEach(t=>drawTank(t));
  // shell
  if(shell){ drawShell(shell); }
}
function drawTank(t){
  // body
  ctx.save();
  ctx.shadowColor=t.color; ctx.shadowBlur=12;
  ctx.fillStyle=t.color;
  ctx.beginPath(); ctx.roundRect(t.x-16,t.y-10,32,20,6); ctx.fill();
  ctx.shadowBlur=0;
  // turret
  ctx.strokeStyle='#e5e7eb'; ctx.lineWidth=3;
  const ang=(turn===1?ui.angle.value:180-ui.angle.value)*Math.PI/180;
  const dir=t.dir;
  ctx.beginPath();
  ctx.moveTo(t.x, t.y-6);
  ctx.lineTo(t.x + dir*Math.cos(ang)*18, t.y-6 - Math.sin(ang)*18);
  ctx.stroke();
  ctx.restore();
}
function drawShell(s){
  ctx.fillStyle='#fff';
  ctx.beginPath(); ctx.arc(s.x,s.y,3,0,Math.PI*2); ctx.fill();
}

function fire(player){
  // pick angle/power based on player facing
  const p=player===1? tanks[0] : tanks[1];
  const angDeg = player===1 ? +ui.angle.value : 180 - (+ui.angle.value);
  const ang = angDeg*Math.PI/180;
  const pow = +ui.power.value/1.2; // scale down for compact arena
  shell={x:p.x + Math.cos(ang)*18, y:p.y-6 - Math.sin(ang)*18, vx:Math.cos(ang)*pow, vy:-Math.sin(ang)*pow, owner:player, t:0};
  animate();
}
function animate(){
  if(!shell) return;
  const step=()=>{
    // physics
    shell.t += 1;
    shell.vx += wind*0.02;      // wind gently affects
    shell.vy += G;
    shell.x  += shell.vx;
    shell.y  += shell.vy;

    // draw
    drawScene();

    // collision with ground/walls
    if(shell.x<0 || shell.x>W || shell.y>H-28){
      explode(shell.x, Math.min(shell.y, H-28));
      endShot();
      return;
    }
    // hit tank?
    const enemy = shell.owner===1? tanks[1] : tanks[0];
    if(dist(shell.x,shell.y, enemy.x, enemy.y) < enemy.r+6){
      explode(shell.x, shell.y, true);
      damage(enemy, Math.floor(18 + Math.random()*12)); // 18â€“30 dmg
      endShot();
      return;
    }
    if(!gameOver) requestAnimationFrame(step);
  };
  requestAnimationFrame(step);
}
function explode(x,y,hit=false){
  // simple radial particle burst
  for(let i=0;i<22;i++){
    const a=Math.random()*Math.PI*2, r=hit? (6+Math.random()*10) : (4+Math.random()*8);
    ctx.fillStyle=hit? '#ffd166' : '#9be8ff';
    ctx.beginPath(); ctx.arc(x+Math.cos(a)*r, y+Math.sin(a)*r, 2, 0, Math.PI*2); ctx.fill();
  }
}
function endShot(){
  shell=null;
  if(gameOver) return;
  turn = (turn===1?2:1);
  statusEl.innerHTML = `Turn: <b style="color:${turn===1?get('--p1'):get('--p2')}">${turn===1?'P1':'P2/Bot'}</b>.`;
  drawScene();
  if(mode==='bot' && turn===2) setTimeout(botFire, 650);
}
function damage(t,amount){
  t.hp = Math.max(0, t.hp-amount);
  updateHP();
  if(t.hp<=0){
    gameOver=true;
    const winner = (t===tanks[0])? 'P2/Bot' : 'P1';
    statusEl.textContent=`ðŸŽ‰ ${winner} wins!`;
  }
}
function updateHP(){
  hp1El.style.width = tanks[0].hp+'%';
  hp2El.style.width = tanks[1].hp+'%';
}

function botFire(){
  if(gameOver) return;
  // Estimate needed angle/power from distance using ballistic formula (no wind), then adjust a bit.
  const me=tanks[1], foe=tanks[0];
  const dx = foe.x - me.x, dy = me.y - foe.y; // note: canvas y downwards
  // Try set power first then compute angle
  let power = 50 + Math.random()*20; // 50â€“70
  const v = power/1.2;
  const g = G;
  const x = Math.abs(dx);
  // Solve for angle using Î¸ = 0.5 * asin( g*x / v^2 ) with simple clamp
  let arg = (g*x)/(v*v);
  arg = Math.min(0.99, Math.max(-0.99,arg));
  let theta = 0.5*Math.asin(arg); // radians (lower trajectory)
  // Add small aim compensation for vertical difference & wind
  theta += (dy/400) + (wind*0.25);
  // Convert for UI (bot uses mirrored angle slider)
  let deg = 180 - Math.max(5, Math.min(85, theta*180/Math.PI));
  // Sprinkle inaccuracy based on difficulty
  deg += (Math.random()*6 - 3);
  power += (Math.random()*8 - 4);

  ui.angle.value = Math.round(180 - deg); // UI shows human-style (5..85)
  ui.power.value = Math.round(Math.max(20, Math.min(90, power)));
  syncLabels();
  fire(2);
}

function dist(x1,y1,x2,y2){ const dx=x1-x2, dy=y1-y2; return Math.hypot(dx,dy); }

// init
reset();
drawScene();
</script>
</body>
</html>
