<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>2048 — Fusion</title>
<style>
  :root{
    --bg:#191919; --panel:#1e1e1e; --tile:#222; --text:#e8eef3; --accent:#00ffa6;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
    font-family:Inter,system-ui,Segoe UI,Roboto,Arial;display:flex;align-items:center;justify-content:center}
  .wrap{width: min(96vw,560px); padding:18px}
  .top{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  h1{margin:0;font-size:20px}
  .stats{display:flex;gap:8px}
  .badge{background:#222;border:1px solid #2b2b2b;border-radius:10px;padding:8px 12px;font-weight:700}
  .btns{display:flex;gap:8px}
  button{background:#222;border:1px solid #2b2b2b;color:#fff;padding:8px 12px;border-radius:10px;cursor:pointer}
  .primary{background:var(--accent);color:#08140e;border:none;font-weight:800}
  .board{position:relative;background:var(--panel);padding:10px;border-radius:14px;
    display:grid;grid-template-columns:repeat(4,1fr);gap:10px;box-shadow:0 20px 50px rgba(0,0,0,.55)}
  .cell{background:#191919;border-radius:10px;aspect-ratio:1/1}
  .tile{position:absolute;display:flex;align-items:center;justify-content:center;
    font-weight:900;border-radius:12px;box-shadow:0 8px 20px rgba(0,0,0,.4);transform:translateZ(0)}
  .foot{margin-top:10px;font-size:13px;color:#b9c1c7;text-align:center}
</style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <h1>2048 — Fusion</h1>
    <div class="stats">
      <div class="badge">Score: <span id="score">0</span></div>
      <div class="badge">Best: <span id="best">0</span></div>
    </div>
    <div class="btns">
      <button id="new" class="primary">New Game</button>
      <button id="undo">Undo</button>
    </div>
  </div>

  <div id="board" class="board" aria-label="2048 board">
    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
    <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
  </div>

  <div class="foot">Controls: Swipe (mobile) • Arrow keys / WASD (desktop)</div>
</div>

<script>
/* 2048 — Fusion: single-file, smooth tiles, swipe + keyboard, undo + best score */
const N=4, boardEl=document.getElementById('board');
const SPACING=10, PAD=10; // matches CSS
let grid, tiles=[], score=0, best=+(localStorage.getItem('fusion2048best')||0);
let history=[]; // for undo

const scoreEl=document.getElementById('score'), bestEl=document.getElementById('best');
bestEl.textContent=best;

function reset(){
  grid=[...Array(N)].map(()=>Array(N).fill(0));
  tiles=[]; score=0; updateScore();
  addRandom(); addRandom(); layout();
}
function cloneState(){ return {grid: grid.map(r=>r.slice()), score}; }
function pushHistory(){ history.push(cloneState()); if(history.length>40) history.shift(); }
function popHistory(){
  if(!history.length) return;
  const s=history.pop(); grid=s.grid; score=s.score; layout(true);
  updateScore();
}

// positions
function cellSize(){ // px
  const w=boardEl.clientWidth;
  return (w - PAD*2 - SPACING*(N-1)) / N;
}
function bbox(r,c){ // px rect for a cell
  const size=cellSize();
  const x = PAD + c*(size+SPACING);
  const y = PAD + r*(size+SPACING);
  return {x,y,size};
}

// colors per value
function tileColor(v){
  const map={
    2:'#2dd4bf',4:'#22d3ee',8:'#60a5fa',16:'#a78bfa',32:'#fb7185',64:'#f59e0b',
    128:'#34d399',256:'#06b6d4',512:'#8b5cf6',1024:'#f43f5e',2048:'#fcd34d'
  };
  return map[v] || '#e5e7eb';
}
function textColor(v){ return v<=4?'#0b1718':'#0b1418'; }

// render
function layout(skipAnim=false){
  // remove existing dom tiles
  [...document.querySelectorAll('.tile')].forEach(t=>t.remove());
  const size=cellSize();
  // render tiles from grid
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const v=grid[r][c]; if(!v) continue;
      const {x,y}=bbox(r,c);
      const el=document.createElement('div');
      el.className='tile';
      el.style.width=el.style.height=size+'px';
      el.style.left=x+'px'; el.style.top=y+'px';
      el.style.background=tileColor(v);
      el.style.color=textColor(v);
      el.style.fontSize=(v<100? size*0.42 : v<1000? size*0.36 : size*0.30) + 'px';
      el.textContent=v;
      if(!skipAnim){ el.animate([{transform:'scale(.8)'},{transform:'scale(1)'}],{duration:120,easing:'ease-out'}); }
      boardEl.appendChild(el);
    }
  }
}

// random add
function emptyCells(){
  const res=[];
  for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(!grid[r][c]) res.push([r,c]);
  return res;
}
function addRandom(){
  const emp=emptyCells(); if(!emp.length) return false;
  const [r,c]=emp[Math.floor(Math.random()*emp.length)];
  grid[r][c]=Math.random()<0.9?2:4; return true;
}

// moves
function compress(row){
  const vals=row.filter(v=>v); // remove zeros
  for(let i=0;i<vals.length-1;i++){
    if(vals[i]===vals[i+1]){ vals[i]*=2; score+=vals[i]; vals.splice(i+1,1); }
  }
  while(vals.length<N) vals.push(0);
  return vals;
}
function moveLeft(){
  pushHistory();
  let moved=false;
  for(let r=0;r<N;r++){
    const old=grid[r].slice();
    const comp=compress(old);
    grid[r]=comp;
    if(!arraysEqual(old,comp)) moved=true;
  }
  if(moved){ addRandom(); layout(); updateScore(); checkGameOver(); }
}
function moveRight(){
  pushHistory();
  let moved=false;
  for(let r=0;r<N;r++){
    const old=grid[r].slice().reverse();
    const comp=compress(old).reverse();
    if(!arraysEqual(grid[r],comp)) moved=true;
    grid[r]=comp;
  }
  if(moved){ addRandom(); layout(); updateScore(); checkGameOver(); }
}
function moveUp(){
  pushHistory();
  let moved=false;
  for(let c=0;c<N;c++){
    const col=[grid[0][c],grid[1][c],grid[2][c],grid[3][c]];
    const comp=compress(col);
    for(let r=0;r<N;r++){ if(grid[r][c]!==comp[r]) moved=true; grid[r][c]=comp[r]; }
  }
  if(moved){ addRandom(); layout(); updateScore(); checkGameOver(); }
}
function moveDown(){
  pushHistory();
  let moved=false;
  for(let c=0;c<N;c++){
    const col=[grid[3][c],grid[2][c],grid[1][c],grid[0][c]];
    const comp=compress(col);
    const out=[comp[3],comp[2],comp[1],comp[0]];
    for(let r=0;r<N;r++){ if(grid[r][c]!==out[r]) moved=true; grid[r][c]=out[r]; }
  }
  if(moved){ addRandom(); layout(); updateScore(); checkGameOver(); }
}

function arraysEqual(a,b){ return a.length===b.length && a.every((v,i)=>v===b[i]); }

function updateScore(){
  scoreEl.textContent=score;
  if(score>best){ best=score; localStorage.setItem('fusion2048best',best); bestEl.textContent=best; }
}

function movesAvailable(){
  if(emptyCells().length) return true;
  // check adjacent equal
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    const v=grid[r][c];
    if((c+1<N && grid[r][c+1]===v) || (r+1<N && grid[r+1][c]===v)) return true;
  }
  return false;
}
function checkGameOver(){
  if(!movesAvailable()){
    setTimeout(()=>alert('Game Over! Score: '+score), 50);
  }
}

// input
window.addEventListener('keydown',e=>{
  const k=e.key.toLowerCase();
  if(k==='arrowleft'||k==='a') moveLeft();
  if(k==='arrowright'||k==='d') moveRight();
  if(k==='arrowup'||k==='w') moveUp();
  if(k==='arrowdown'||k==='s') moveDown();
});
let start=null;
boardEl.addEventListener('touchstart',e=>{ const t=e.touches[0]; start={x:t.clientX,y:t.clientY};},{passive:true});
boardEl.addEventListener('touchend',e=>{
  if(!start) return;
  const t=e.changedTouches[0]; const dx=t.clientX-start.x, dy=t.clientY-start.y;
  if(Math.abs(dx)>Math.abs(dy)){ if(dx>20) moveRight(); else if(dx<-20) moveLeft(); }
  else { if(dy>20) moveDown(); else if(dy<-20) moveUp(); }
  start=null;
},{passive:true});

// buttons
document.getElementById('new').onclick=()=>{ reset(); };
document.getElementById('undo').onclick=()=>{ popHistory(); };

window.addEventListener('resize',()=>layout(true));

reset();
</script>
</body>
</html>
