<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Memory Match — Glow Cards</title>
<style>
  :root{
    --bg:#191919; --panel:#1b1b1b; --card:#232323; --accent:#00ffa6; --text:#eaf2f6;
    --ok:#34d399; --bad:#fb7185;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
    font-family:Inter,system-ui,Segoe UI,Roboto,Arial;display:flex;align-items:center;justify-content:center}
  .wrap{width:min(96vw,900px);padding:18px}
  .top{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-bottom:12px}
  h1{margin:0;font-size:20px}
  .stats{display:flex;gap:10px;flex-wrap:wrap}
  .badge{background:#202020;border:1px solid #2a2a2a;border-radius:10px;padding:8px 12px;font-weight:700}
  .btns{display:flex;gap:8px;flex-wrap:wrap}
  button,select{background:#202020;border:1px solid #2a2a2a;color:#fff;padding:8px 12px;border-radius:10px;cursor:pointer}
  .primary{background:var(--accent);border:none;color:#07120e;font-weight:800}
  .grid{display:grid;gap:12px;background:var(--panel);padding:14px;border-radius:12px;box-shadow:0 22px 60px rgba(0,0,0,.55)}
  /* cards */
  .card{position:relative;aspect-ratio:3/4;perspective:900px;border-radius:12px}
  .inner{position:absolute;inset:0;border-radius:12px;transform-style:preserve-3d;transition:transform .32s ease}
  .card.flipped .inner{transform:rotateY(180deg)}
  .face{position:absolute;inset:0;border-radius:12px;display:flex;align-items:center;justify-content:center;
    font-size:clamp(28px,8vw,54px);font-weight:900;backface-visibility:hidden}
  .front{background:linear-gradient(180deg,#242424,#1e1e1e);border:1px solid #2a2a2a;
    box-shadow:0 10px 28px rgba(0,0,0,.5), 0 0 0 1px rgba(255,255,255,.03) inset}
  .back{transform:rotateY(180deg);background:linear-gradient(180deg,#0f2027,#203a43,#2c5364);
    box-shadow:0 0 24px rgba(0,255,166,.25);border:1px solid rgba(255,255,255,.12)}
  .match .back{outline:2px solid var(--ok);box-shadow:0 0 24px rgba(52,211,153,.5)}
  .wrong .back{outline:2px solid var(--bad)}
  .foot{margin-top:10px;font-size:13px;color:#b8c1c8;text-align:center}
  @media (max-width:680px){ .stats{justify-content:center} }
</style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div>
      <h1>Memory Match — Glow Cards</h1>
      <div style="font-size:13px;color:#cbd5e1">Flip two cards to find pairs. Finish fast with fewer moves!</div>
    </div>
    <div class="stats">
      <div class="badge">Moves: <span id="moves">0</span></div>
      <div class="badge">Time: <span id="time">00:00</span></div>
      <div class="badge">Best: <span id="best">—</span></div>
    </div>
    <div class="btns">
      <select id="size">
        <option value="4x4" selected>4 x 4 (Easy)</option>
        <option value="5x4">5 x 4 (Normal)</option>
        <option value="6x4">6 x 4 (Challenging)</option>
      </select>
      <button id="restart" class="primary">New Game</button>
    </div>
  </div>

  <div id="grid" class="grid" aria-label="Memory grid"></div>
  <div class="foot">Tip: Mobile tap / Desktop click. Cards auto-check. Background is dark for Notion embeds.</div>
</div>

<script>
/* Memory Match — single file, premium glow look, mobile-friendly */
const icons = ["🍀","⭐","🔥","🌙","⚡","🌸","🎯","🎵","🍎","❄️","🧩","💎","🚀","🌈","🍩","🎲","🪐","🧠","🐾","🍊"];
const gridEl = document.getElementById('grid');
const movesEl = document.getElementById('moves');
const timeEl = document.getElementById('time');
const bestEl = document.getElementById('best');
const sizeSel = document.getElementById('size');
const restartBtn = document.getElementById('restart');

let cols=4, rows=4;
let lock=false, sel=[], moves=0, t0=null, timerId=null, matched=0, totalPairs=0;

function setGridTemplate(){
  gridEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
}
function pad(n){ return n<10? '0'+n : n; }
function fmt(ms){
  const s = Math.floor(ms/1000), m = Math.floor(s/60), ss = s%60;
  return `${pad(m)}:${pad(ss)}`;
}
function bestKey(){ return `mem_best_${cols}x${rows}`; }
function loadBest(){ const v = localStorage.getItem(bestKey()); bestEl.textContent = v ? v : '—'; }

function buildDeck(){
  const need = (cols*rows)/2;
  const deck = icons.slice(0,need);
  const full = deck.concat(deck).map((v,i)=>({id:i,icon:v}));
  // shuffle
  for(let i=full.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [full[i],full[j]] = [full[j],full[i]]; }
  return full;
}

function startTimer(){
  t0 = performance.now();
  clearInterval(timerId);
  timerId = setInterval(()=>{ timeEl.textContent = fmt(performance.now()-t0); }, 200);
}
function stopTimer(){ clearInterval(timerId); timerId=null; }

function newGame(){
  lock=false; sel=[]; moves=0; matched=0;
  movesEl.textContent = moves; timeEl.textContent = '00:00';
  setGridTemplate();
  gridEl.innerHTML = '';
  const deck = buildDeck();
  totalPairs = deck.length/2;
  deck.forEach(card=>{
    const el = document.createElement('div');
    el.className='card';
    el.innerHTML = `
      <div class="inner" data-icon="${card.icon}">
        <div class="face front">✦</div>
        <div class="face back">${card.icon}</div>
      </div>`;
    gridEl.appendChild(el);
  });
  startTimer();
}

function handleFlip(cardEl){
  if(lock) return;
  if(cardEl.classList.contains('flipped')) return;
  cardEl.classList.add('flipped');
  sel.push(cardEl);
  if(sel.length===2){
    moves++; movesEl.textContent = moves;
    const a = sel[0].querySelector('.inner').dataset.icon;
    const b = sel[1].querySelector('.inner').dataset.icon;
    if(a===b){
      // match
      sel.forEach(c=>c.classList.add('match'));
      matched++;
      sel = [];
      if(matched===totalPairs){
        stopTimer();
        const elapsed = timeEl.textContent;
        // store best (fewest moves first, then time)
        const prev = localStorage.getItem(bestKey());
        const currScore = JSON.stringify({moves, time: elapsed});
        if(!prev){
          localStorage.setItem(bestKey(), currScore);
        }else{
          const p = JSON.parse(prev);
          const better = (moves < p.moves) || (moves===p.moves && elapsed < p.time);
          if(better) localStorage.setItem(bestKey(), currScore);
        }
        loadBest();
        setTimeout(()=>alert(`🎉 Completed!\nMoves: ${moves}\nTime: ${elapsed}`), 250);
      }
    }else{
      // wrong → brief highlight then flip back
      lock = true;
      sel.forEach(c=>c.classList.add('wrong'));
      setTimeout(()=>{
        sel.forEach(c=>{ c.classList.remove('flipped','wrong'); });
        sel = []; lock = false;
      }, 700);
    }
  }
}

// events
gridEl.addEventListener('click', e=>{
  const card = e.target.closest('.card');
  if(!card) return; handleFlip(card);
},{passive:true});

sizeSel.addEventListener('change', ()=>{
  const v = sizeSel.value; const [c,r] = v.split('x').map(n=>+n);
  cols=c; rows=r; loadBest(); newGame();
});
restartBtn.addEventListener('click', ()=>{ newGame(); });

function init(){
  loadBest();
  newGame();
}
window.addEventListener('resize', ()=>{ /* responsive font handled by CSS */ });
init();
</script>
</body>
</html>
